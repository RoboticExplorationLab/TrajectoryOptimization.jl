<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimizing Rotations · TrajectoryOptimization</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TrajectoryOptimization</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="model.html">1. Setting Up a Dynamics Model</a></li><li><a class="tocitem" href="costfunctions.html">2. Setting up an Objective</a></li><li><a class="tocitem" href="constraints.html">3. Creating Constraints</a></li><li><a class="tocitem" href="creating_problems.html">4. Setting up a Problem</a></li></ul></li><li><span class="tocitem">Interfaces</span><ul><li><a class="tocitem" href="costfunction_interface.html">Cost Function Interface</a></li><li><a class="tocitem" href="constraint_interface.html">Constraint Interface</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="cost_api.html">Cost Functions and Objectives</a></li><li><a class="tocitem" href="constraint_api.html">Constraints</a></li><li><a class="tocitem" href="problem.html">Problem</a></li><li class="is-active"><a class="tocitem" href="rotations.html">Optimizing Rotations</a><ul class="internal"><li><a class="tocitem" href="#Cost-Functions-(experimental)"><span>Cost Functions (experimental)</span></a></li><li><a class="tocitem" href="#Cost-and-Constraint-Expansions"><span>Cost and Constraint Expansions</span></a></li></ul></li><li><a class="tocitem" href="dynamics.html">Evaluating the Dynamics and Jacobians</a></li><li><a class="tocitem" href="nlp.html">Converting to an NLP</a></li></ul></li><li><a class="tocitem" href="examples.html">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="rotations.html">Optimizing Rotations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="rotations.html">Optimizing Rotations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/master/docs/src/rotations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimizing-Rotations"><a class="docs-heading-anchor" href="#Optimizing-Rotations">Optimizing Rotations</a><a id="Optimizing-Rotations-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-Rotations" title="Permalink"></a></h1><p>Optimization over the space of rotations is non-trivial due to the group structure  of 3D rotations. TrajectoryOptimization.jl provides methods for accounting for this group structure, both in the constraints and in the objective. We make the assumption that 3D rotation only show up in the state vector, and never in the control vector. TrajectoryOptimization.jl relies on the dynamics model to determine if the state vector contains rotations. See the  <a href="http://roboticexplorationlab.org/RobotDynamics.jl/dev/liemodel.html">RobotDynamics.jl documentation</a> for more details on defining models with rotations. From here, we assume that we are dealing with a model that inherits from <a href="http://roboticexplorationlab.org/RobotDynamics.jl/dev/liemodel.html#LieGroupModel-API-1"><code>RobotDynamics.LieGroupModel</code></a>.</p><h2 id="Cost-Functions-(experimental)"><a class="docs-heading-anchor" href="#Cost-Functions-(experimental)">Cost Functions (experimental)</a><a id="Cost-Functions-(experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-Functions-(experimental)" title="Permalink"></a></h2><p>While normal quadratic cost functions can work with rotations (e.g. <span>$q_k^T Q q_k$</span>, where <span>$q_k$</span> is a quaternion, MRP, or RP), this distance metric isn&#39;t well-defined.  Since we often want to penalize the distance from a reference rotation  (such as a nominal or goal state), TrajectoryOptimization.jl provides a couple different methods for penalizing distance from a reference rotation. However, we&#39;ve  discovered that the quaternion geodesic distance: </p><p class="math-container">\[\min 1 \pm q_d^T q_k\]</p><p>where <span>$q_d$</span> is the desired, or reference, quaternion, works the best. We&#39;ve also  found that, while technically incorrect, a naive quadratic penalty can work quite well, especially when the difference between the rotations isn&#39;t significant. </p><p>The following cost functions are provided. Note that these methods should still be  considered experimental, and the interface made change in the future. If you encounter any issues using these functions, please submit an issue.</p><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.DiagonalQuatCost" href="#TrajectoryOptimization.DiagonalQuatCost"><code>TrajectoryOptimization.DiagonalQuatCost</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiagonalQuatCost</code></pre><p>Quadratic cost function for states that includes a 3D rotation, that penalizes deviations      from a provided 3D rotation, represented as a Unit Quaternion.</p><p>The cost function penalizes geodesic distance between unit quaternions:</p><p><span>$\frac{1}{2} \big( x^T Q x + u^T R u \big) + q^T x + r^T u + c + w \min 1 \pm p_f^T p$</span></p><p>where <span>$p$</span> is the quaternion extracted from <span>$x$</span> (i.e. <code>p = x[q_ind]</code>), and <span>$p_f$</span>  is the reference quaternion. <span>$Q$</span> and <span>$R$</span> are assumed to be diagonal.</p><p>We&#39;ve found this perform better than penalizing a quadratic on the quaternion error  state (<a href="rotations.html#TrajectoryOptimization.ErrorQuadratic"><code>ErrorQuadratic</code></a>). This cost should still be considered experimental.</p><p><strong>Constructors</strong></p><ul><li><code>DiagonalQuatCost(Q::Diagonal, R::Diagonal, q, r, c, w, q_ref, q_ind; terminal)</code></li><li><code>DiagonalQuatCost(Q::Diagonal, R::Diagonal; q, r, c, w, q_ref, q_ind, terminal)</code></li></ul><p>where <code>q_ref</code> is the reference quaternion (provided as a <code>SVector{4}</code>), and      <code>q_ind::SVector{4,Int}</code> provides the indices of the quaternion in the state vector      (default = <code>SA[4,5,6,7]</code>). Note that <code>Q</code> and <code>q</code> are the size of the full state,      so <code>Q.diag[q_ind]</code> and <code>q[qind]</code> should typically be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2d5467840bca8927110fbb3ee545d35c7a06e19b/src/lie_costs.jl#L228-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.QuatLQRCost" href="#TrajectoryOptimization.QuatLQRCost"><code>TrajectoryOptimization.QuatLQRCost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">QuatLQRCost(Q, R, xf, [uf; w, quat_ind])</code></pre><p>Defines a cost function of the form:</p><p><span>$\frac{1}{2} \big( (x - x_f)^T Q (x - x_f) + (u - u_f)^T R (u - u_f) \big) + w \min 1 \pm q_f^T q$</span></p><p>where <span>$Q$</span> and <span>$R$</span> are diagonal, <span>$x_f$</span> is the goal state,  <span>$u_f$</span> is the reference control, and <span>$q_f$</span>, <span>$q$</span> are the quaternions, extracted from <span>$x$</span> using <code>quat_ind</code>, i.e. <code>q = x[quat_ind]</code>.</p><p>The last term is the geodesic distance between quaternions. It&#39;s typically recommended that  <code>Q.diag[quad_ind] == zeros(4)</code>.</p><p>This is just a convenience constructor for <a href="rotations.html#TrajectoryOptimization.DiagonalQuatCost"><code>DiagonalQuatCost</code></a>.</p><p><strong>Example</strong></p><p>For a standard rigid body state vector <code>x = [p; q; v; ω]</code>, where <code>q</code> is a unit quaternion, we could define a cost function that penalizes the distance to the goal state <code>xf</code>.  We can create this cost function as follows:</p><pre><code class="language-julia">Q = Diagonal(SVector(RBState(fill(0.1,3), zeros(4), fill(0.1,3), fill(0.1,3))))
R = Diagonal(@SVector fill(0.01, 6))
xf = RBState([1,2,3], rand(UnitQuaternion), zeros(3), zeros(3))
QuatLQRCost(Q,R,xf)</code></pre><p>We can add a reference control and change the weight on the rotation error with the optional arguments:</p><pre><code class="language-julia">QuatLQRCost(Q,R,xf,uf, w=10.0)</code></pre><p>which is equivalent to</p><pre><code class="language-julia">QuatLQRCost(Q,R,xf,uf, w=10.0, quat_inds=4:7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2d5467840bca8927110fbb3ee545d35c7a06e19b/src/lie_costs.jl#L315-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TrajectoryOptimization.ErrorQuadratic" href="#TrajectoryOptimization.ErrorQuadratic"><code>TrajectoryOptimization.ErrorQuadratic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ErrorQuadratic{Rot,N,M}</code></pre><p>Cost function of the form:</p><p><span>$\frac{1}{2} (x_k \ominus x_d)^T Q_k (x_k \ominus x_d)$</span></p><p>where <span>$x_k \ominus x_d$</span> is the error state, computed using  <code>RobotDynamics.state_diff</code>.  This cost function isn&#39;t recommended: we&#39;ve found that <code>DiagonalQuatCost</code> usually     peforms better and is much more computationally efficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl/blob/2d5467840bca8927110fbb3ee545d35c7a06e19b/src/lie_costs.jl#L396-L407">source</a></section></article><h2 id="Cost-and-Constraint-Expansions"><a class="docs-heading-anchor" href="#Cost-and-Constraint-Expansions">Cost and Constraint Expansions</a><a id="Cost-and-Constraint-Expansions-1"></a><a class="docs-heading-anchor-permalink" href="#Cost-and-Constraint-Expansions" title="Permalink"></a></h2><p>The key to performing optimization on Lie Groups such as rotations is to perform  the optimization on the tangent bundle, or simply the hyperplane tangent to the  group at the current iterate. Since the tangent space is Euclidean, we use  standard optimization methods such as Newton&#39;s method to find a step direction.  After we find a candidate step direction, we project back onto the group using  the exponential map (or any other &quot;retraction map&quot;).  For rotations and unit quaternions, this means we  can either use the exponential map, or use the conversions between unit quaternions and MRPs or RPs (Rodrigues Parameters). Since most optimization methods require gradient or Hessian information, we need to correctly account for the mapping to the the tangent plane when computing derivatives.</p><p>TrajectoryOptimization.jl handles this by first computing the derivatives as normal,  treating the state (naively) as a vector in Euclidean space. This means methods such  as ForwardDiff can be used without problem. These derivatives are then &quot;converted&quot;  to work on the error state. This conversion ends up being one or two extra matrix  multiplications with the so-called &quot;error-state Jacobian,&quot; which is a function of the rotation at the current iterate. </p><p>Therefore, computing the full derivative information is split into 2 steps:</p><ol><li>Compute the derivatives as normal.</li><li>Compute the &quot;error expansion,&quot; using the result of step 1.</li></ol><p>For objectives this looks like:</p><pre><code class="language-julia">TrajectoryOptimization.state_diff_jacobian!(G, model, Z)
TrajectoryOptimization.cost_expansion!(E0, obj, Z, [init, rezero])
TrajectoryOptimization.error_expansion!(E, E0, model, Z, G)</code></pre><p>The corrected expansion is stored in <code>E::QuadraticObjective</code>. The first line computes the error-state Jacobians, storing them in <code>G</code>. The intermediate expansion is stored  in <code>E0::QuadraticObjective</code>. For models that do not have rotations, <code>E === E0</code> and the last line is a no-op.</p><p>For dynamics this looks very similar:</p><pre><code class="language-julia">TrajectoryOptimization.state_diff_jacobian!(G, model, Z)
TrajectoryOptimization.dynamics_expansion!(::Type{Q}, D::DynamicsExpansion, model, Z)
TrajectoryOptimization.error_expansion!(D::DynamicsExpansion, model, G)</code></pre><p>The first line can be omitted if it has already be computed for the current  trajectory <code>Z::AbstractTrajectory</code>.</p><p>This functionality is still under development for constraints. Since augmented  Lagrangian methods incorporate the constraints into the objective, the error  expansion is computed on the entire cost, rather than computing an intermediate error expansion for the constraints, saving computation. If you need this  functionality, please submit an issue.</p><p>The experimental interface is currently:</p><pre><code class="language-julia">TrajectoryOptimization.jacobian!(conSet::AbstractConstraintSet, Z::AbstractTrajectory, [init])
TrajectoryOptimization.error_expansion!(conSet::AbstractConstraintSet, model, G)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="problem.html">« Problem</a><a class="docs-footer-nextpage" href="dynamics.html">Evaluating the Dynamics and Jacobians »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 22 February 2021 14:14">Monday 22 February 2021</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
